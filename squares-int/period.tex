Quand il ne se fige pas, le code suivant donne la \textit{\og période \fg} d'un naturel auquel on applique le procédé.

\begin{rawcode}
n     = 20181209
nmemo = n

results = []

while n not in results:
    results.append(n)
    n = sum(int(d)**2 for d in str(n))

print(f"{nmemo} a la période suivante :")
print(results[results.index(n):])

print()

before = results[:results.index(n)]

if before:
    print("Avant la 1ère période nous avons :")
    print(before)
else:
    print("On commence directement par la période.")
\end{rawcode}

\medskip

Le code précédent, où \verb+n = 20181209+, nous affiche :

\begin{rawcode}
20181209 a la période suivante :
[16, 37, 58, 89, 145, 42, 20, 4]

Avant la 1ère période nous avons :
[20181209, 155, 51, 26, 40]
\end{rawcode}


\medskip

Amusons-nous maintenant à représenter un histogramme des effectifs pour la taille des \og périodes \fg{}.
Le code utilisé se trouve à l'adresse \url{https://github.com/bc-writing/drafts} : voir le fichier \texttt{squareint-sizeplots.py} dans le dossier \texttt{squares-int}.
Le traitement des données a été amélioré pour éviter de refaire des calculs déjà rencontrés \emph{(pour plus de précisions, le lecteur curieux se reportera aux commentaires du code)}.
Voici ce que l'on obtient
\footnote{
	À l'adresse \url{https://github.com/bc-writing/drafts} dans le dossier \texttt{squares-int} vous trouverez l'image \texttt{befores.png} qui est un histogramme des effectifs pour la taille des suites de naturels juste avant la 1\iere{} \og période \fg{}.
}.

\begin{center}
	\includegraphics[scale=.9]{squares-int/periods.png}
\end{center}


\medskip

Voilà quelque chose de frappant ! Il semblerait que l'on ait soit des périodes de taille $1$, penser à $0$ et $1$, soit des périodes de taille $8$ comme pour $37 - 58 - 89 - 145 - 42 - 20 - 4 - 16$\dots{}
Magie ou coïncidence ? La section \ref{proof} va nous permettre de le savoir. Dans la suite, nous reprenons les notations de la dite section.


\medskip

Tout d'abord, comme $\taille(sq(n)) < \taille(n)$ dès que $\taille(n) \geqslant 4$ d'après le fait 2, la périodicité n'arrivera que lorsque $\taille\left( \, \sqseq{n}{k} \right) \leqslant 3$.


\medskip

De plus, nous savons aussi que $\taille(sq(n)) \leqslant 3$ dès que $\taille(n) \leqslant 3$.


\medskip

Tout ceci nous permet d'analyser brutalement via un programme ce qu'il se passe pour les périodes des naturels appartenant à $\ZintervalC{0}{999}$. Nous pouvons pour cela utiliser le code suivant, qui n'est absolument pas optimisé mais fait le travail immédiatement.


\newpage

\begin{rawcode}
nmax = 999

periodsfound = set()

for n in range(nmax + 1):
    results = []

    while n not in results:
        results.append(n)
        n = sum(int(d)**2 for d in str(n))

    periodsfound.add(
        tuple(results[results.index(n):])
    )

for oneperiod in periodsfound:
    print(oneperiod)
\end{rawcode}


\medskip

Ce code nous fournit les informations suivantes :

\begin{rawcode}
(20, 4, 16, 37, 58, 89, 145, 42)
(0,)
(1,)
(58, 89, 145, 42, 20, 4, 16, 37)
(16, 37, 58, 89, 145, 42, 20, 4)
(37, 58, 89, 145, 42, 20, 4, 16)
(4, 16, 37, 58, 89, 145, 42, 20)
(89, 145, 42, 20, 4, 16, 37, 58)
(42, 20, 4, 16, 37, 58, 89, 145)
(145, 42, 20, 4, 16, 37, 58, 89)
\end{rawcode}


\medskip

Et là cela devient joli car nous avons non seulement la preuve que les périodes sont de taille $1$ ou $8$, mais nous pouvons aussi affirmer que soit $0$, soit $1$, soit $4$ apparaîtra à un moment donné du procédé, et qu'ensuite arrivera le phénomène de périodicité. Que c'est beau !


